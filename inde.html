<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GrayCode Camera Scanner</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; }
    .wrap { max-width: 720px; margin: 0 auto; }
    video { width: 100%; max-height: 70vh; background: #111; border-radius: 12px; object-fit: cover; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin: 12px 0; }
    button { padding: 10px 12px; font-size: 16px; }
    .status { padding: 10px 12px; background: #f3f4f6; border-radius: 12px; }
    .hint { color:#444; font-size: 14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>그레이 코드 실시간 인식</h2>
    <p class="hint">코드를 화면 중앙에 크게 맞추면 자동으로 이동합니다.</p>

    <div class="row">
      <button id="start">카메라 시작</button>
      <button id="stop" disabled>카메라 정지</button>
    </div>

    <div class="status" id="status">대기 중…</div>

    <video id="video" playsinline autoplay muted></video>
  </div>

<script>
(() => {
  // =========================
  // 8x8 전용
  // =========================
  const N = 8;

  // =========================
  // 패턴 정의: 3레벨(0..2) 또는 4레벨(0..3) 혼용 가능
  // =========================
  const PATTERNS = [
    {
      id: "NPL_HOME",
      url: "https://npl.khu.ac.kr/",
      levels: [
        [3,0,2,2,1,3,2,3],
        [3,2,3,0,1,0,3,2],
        [0,1,1,1,0,3,1,1],
        [1,2,0,2,0,3,3,3],
        [3,2,3,0,0,1,2,0],
        [0,0,2,3,0,0,1,1],
        [2,3,3,3,2,3,2,2],
        [2,2,1,1,2,3,2,2]
      ],
    },
    {
      id: "OSK",
      url: "https://www.osk.or.kr/conference/event/index.php?cfrid=136",
      levels: [
        [0,2,1,0,0,0,0,1],
        [1,0,1,1,0,2,1,1],
        [2,0,0,2,1,2,2,1],
        [0,0,1,0,1,0,0,2],
        [2,1,0,2,0,1,0,0],
        [1,2,2,1,2,1,2,0],
        [0,2,2,0,0,2,1,0],
        [1,0,2,2,1,0,0,1]
      ],
    }
  ];

  // =========================
  // 튜닝
  // =========================
  const SCAN_INTERVAL_MS = 140;

  // NOTE: 8x8 + affine fit 기준으로 80은 꽤 관대한 편.
  // 오탐이 많으면 낮추고(예: 50~70), 인식이 안 되면 올리세요(예: 90~120).
  const RMSE_THRESHOLD = 80;

  const DET_W = 480;
  const DET_H = 480;

  const WARP_SIZE = 300;

  // =========================
  // DOM
  // =========================
  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnStart = document.getElementById("start");
  const btnStop  = document.getElementById("stop");

  function setStatus(msg) { statusEl.textContent = msg; }

  // =========================
  // 안전/호환: 캔버스 컨텍스트 폴백
  // =========================
  function get2DContextSafe(canvas) {
    // Safari/일부 브라우저에서 willReadFrequently 옵션 때문에 null 반환되는 경우가 있어 폴백
    return canvas.getContext("2d", { willReadFrequently: true }) || canvas.getContext("2d");
  }

  // 내부 캔버스들
  const detCanvas = document.createElement("canvas");
  detCanvas.width = DET_W; detCanvas.height = DET_H;
  const detCtx = get2DContextSafe(detCanvas);

  const warpCanvas = document.createElement("canvas");
  warpCanvas.width = WARP_SIZE; warpCanvas.height = WARP_SIZE;
  const warpCtx = get2DContextSafe(warpCanvas);

  if (!detCtx || !warpCtx) {
    setStatus("오류: 캔버스 2D 컨텍스트 생성 실패(브라우저 호환성). 다른 브라우저로 시도하세요.");
    return;
  }

  // =========================
  // 패턴 검증 + 레벨 매핑 자동 선택
  // =========================
  function validatePattern(p) {
    if (!Array.isArray(p.levels) || p.levels.length !== N) {
      setStatus(`패턴 오류("${p.id}"): levels는 ${N}x${N}이어야 합니다.`);
      console.error("Pattern size error:", p);
      return false;
    }
    for (const row of p.levels) {
      if (!Array.isArray(row) || row.length !== N) {
        setStatus(`패턴 오류("${p.id}"): 행 길이가 ${N}이 아닙니다.`);
        console.error("Pattern row error:", p);
        return false;
      }
      for (const v of row) {
        // 3레벨(0..2) 또는 4레벨(0..3)만 허용
        if (!Number.isFinite(v) || v < 0 || v > 3) {
          setStatus(`패턴 오류("${p.id}"): 레벨 값 ${v} (허용: 0..3).`);
          console.error("Pattern level error:", p);
          return false;
        }
      }
    }
    return true;
  }

  for (const p of PATTERNS) {
    if (!validatePattern(p)) return;
  }

  function maxLevelOf(levels2d) {
    let m = 0;
    for (const row of levels2d) for (const v of row) if (v > m) m = v;
    return m;
  }

  function levelToGrayForMax(maxLevel) {
    // maxLevel=2 -> 3레벨: [0, mid, 255]
    // maxLevel=3 -> 4레벨: [0, 85, 170, 255]
    if (maxLevel === 2) return [0, 127.5, 255];
    if (maxLevel === 3) return [0, 85, 170, 255];
    // 이 케이스는 사실상 패턴 검증에서 걸러져야 함
    return null;
  }

  // =========================
  // 회전/템플릿
  // =========================
  function rotate90(m) {
    const out = Array.from({length:N}, () => Array(N).fill(0));
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) out[c][N-1-r] = m[r][c];
    return out;
  }

  function levelsToTargetVec(levels2d, levelToGray) {
    const v = new Float32Array(N*N);
    let k = 0;
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) {
      const lv = levels2d[r][c];
      // lv가 0..2인데 4레벨 매핑을 써도 문제는 없지만(인덱싱 가능),
      // 여기서는 패턴별로 정확한 매핑을 선택했으니 그대로 사용
      v[k++] = levelToGray[lv];
    }
    return v;
  }

  const ROT_PATTERNS = PATTERNS.map(p => {
    const r0 = p.levels;
    const maxLv = maxLevelOf(r0);
    const map = levelToGrayForMax(maxLv);

    if (!map) {
      setStatus(`패턴 오류("${p.id}"): maxLevel=${maxLv}는 지원하지 않습니다(0..2 또는 0..3만).`);
      console.error("Unsupported max level:", p);
      return null;
    }

    const r1 = rotate90(r0);
    const r2 = rotate90(r1);
    const r3 = rotate90(r2);

    return {
      id: p.id,
      url: p.url,
      targets: [
        levelsToTargetVec(r0, map),
        levelsToTargetVec(r1, map),
        levelsToTargetVec(r2, map),
        levelsToTargetVec(r3, map),
      ]
    };
  }).filter(Boolean);

  if (ROT_PATTERNS.length === 0) {
    setStatus("오류: 유효한 패턴이 없습니다.");
    return;
  }

  // =========================
  // 상태
  // =========================
  let stream = null;
  let timer = null;
  let opened = false;
  let okStreak = 0;

  // =========================
  // 기본 유틸
  // =========================
  function rgbToGray(r, g, b) {
    return 0.299*r + 0.587*g + 0.114*b;
  }

  // ROI를 detCanvas로 가져오기(영상 전체를 정사각형으로 crop 후 다운샘플)
  function captureToDetCanvas() {
    const vw = video.videoWidth, vh = video.videoHeight;
    if (!vw || !vh) return false;

    const s = Math.min(vw, vh);
    const sx = Math.floor((vw - s)/2);
    const sy = Math.floor((vh - s)/2);
    detCtx.drawImage(video, sx, sy, s, s, 0, 0, DET_W, DET_H);
    return true;
  }

  // =========================
  // 에지 계산(소벨)
  // =========================
  function sobelEdges(gray, w, h) {
    const mag = new Float32Array(w*h);
    const idx = (x,y)=>y*w+x;
    for (let y=1;y<h-1;y++) {
      for (let x=1;x<w-1;x++) {
        const gx =
          -gray[idx(x-1,y-1)] + gray[idx(x+1,y-1)] +
          -2*gray[idx(x-1,y)]   + 2*gray[idx(x+1,y)] +
          -gray[idx(x-1,y+1)] + gray[idx(x+1,y+1)];
        const gy =
          -gray[idx(x-1,y-1)] -2*gray[idx(x,y-1)] -gray[idx(x+1,y-1)] +
           gray[idx(x-1,y+1)] +2*gray[idx(x,y+1)] +gray[idx(x+1,y+1)];
        mag[idx(x,y)] = Math.abs(gx) + Math.abs(gy);
      }
    }
    return mag;
  }

  // =========================
  // 사각형 4점 추정(간단)
  // =========================
  function estimateQuadFromEdges(mag, w, h) {
    // 퍼센타일 임계값: 전체 sort (무겁지만 단순/확실). 필요하면 샘플링으로 바꿀 수 있음.
    const arr = Array.from(mag);
    arr.sort((a,b)=>a-b);
    const thr = arr[Math.floor(arr.length*0.92)] || 0; // 상위 8%
    if (thr <= 0) return null;

    let tl=null,tr=null,br=null,bl=null;
    let bestTL=Infinity, bestTR=Infinity, bestBR=-Infinity, bestBL=-Infinity;

    for (let y=0;y<h;y++) {
      for (let x=0;x<w;x++) {
        const m = mag[y*w+x];
        if (m < thr) continue;

        const s1 = x + y;
        const s2 = -x + y;

        if (s1 < bestTL) { bestTL = s1; tl = {x,y}; }
        if (s2 < bestTR) { bestTR = s2; tr = {x,y}; }
        if (s1 > bestBR) { bestBR = s1; br = {x,y}; }
        if (s2 > bestBL) { bestBL = s2; bl = {x,y}; }
      }
    }

    if (!tl || !tr || !br || !bl) return null;

    const areaApprox = Math.abs((br.x-tl.x)*(br.y-tl.y));
    if (areaApprox < (w*h*0.02)) return null;

    return [tl,tr,br,bl];
  }

  // =========================
  // 호모그래피/원근 보정
  // =========================
  function computeHomography(src, dst) {
    const A = [];
    const b = [];
    for (let i=0;i<4;i++) {
      const x = src[i].x, y = src[i].y;
      const u = dst[i].x, v = dst[i].y;
      A.push([x,y,1, 0,0,0, -u*x, -u*y]); b.push(u);
      A.push([0,0,0, x,y,1, -v*x, -v*y]); b.push(v);
    }
    const n = 8;
    for (let col=0; col<n; col++) {
      let pivot = col;
      for (let r=col+1;r<n;r++) if (Math.abs(A[r][col]) > Math.abs(A[pivot][col])) pivot = r;
      [A[col], A[pivot]] = [A[pivot], A[col]];
      [b[col], b[pivot]] = [b[pivot], b[col]];

      const div = A[col][col];
      if (Math.abs(div) < 1e-9) return null;
      for (let c=col;c<n;c++) A[col][c] /= div;
      b[col] /= div;

      for (let r=0;r<n;r++) {
        if (r===col) continue;
        const factor = A[r][col];
        for (let c=col;c<n;c++) A[r][c] -= factor*A[col][c];
        b[r] -= factor*b[col];
      }
    }
    const h = b;
    return [
      [h[0],h[1],h[2]],
      [h[3],h[4],h[5]],
      [h[6],h[7],1]
    ];
  }

  function invert3x3(M) {
    const a=M[0][0], b=M[0][1], c=M[0][2];
    const d=M[1][0], e=M[1][1], f=M[1][2];
    const g=M[2][0], h=M[2][1], i=M[2][2];
    const A = e*i - f*h;
    const B = -(d*i - f*g);
    const C = d*h - e*g;
    const D = -(b*i - c*h);
    const E = a*i - c*g;
    const F = -(a*h - b*g);
    const G = b*f - c*e;
    const H = -(a*f - c*d);
    const I = a*e - b*d;
    const det = a*A + b*B + c*C;
    if (Math.abs(det) < 1e-9) return null;
    const invDet = 1/det;
    return [
      [A*invDet, D*invDet, G*invDet],
      [B*invDet, E*invDet, H*invDet],
      [C*invDet, F*invDet, I*invDet]
    ];
  }

  function applyH(H, x, y) {
    const nx = H[0][0]*x + H[0][1]*y + H[0][2];
    const ny = H[1][0]*x + H[1][1]*y + H[1][2];
    const nz = H[2][0]*x + H[2][1]*y + H[2][2];
    return { x: nx/nz, y: ny/nz };
  }

  function warpFromDetCanvas(quad) {
    const dst = [
      {x:0, y:0},
      {x:WARP_SIZE-1, y:0},
      {x:WARP_SIZE-1, y:WARP_SIZE-1},
      {x:0, y:WARP_SIZE-1},
    ];
    const H = computeHomography(quad, dst);
    if (!H) return null;
    const Hinv = invert3x3(H);
    if (!Hinv) return null;

    const srcImg = detCtx.getImageData(0,0,DET_W,DET_H);
    const sdata = srcImg.data;

    const out = warpCtx.createImageData(WARP_SIZE, WARP_SIZE);
    const odata = out.data;

    for (let y=0;y<WARP_SIZE;y++) {
      for (let x=0;x<WARP_SIZE;x++) {
        const p = applyH(Hinv, x, y);
        const u = Math.max(0, Math.min(DET_W-1, p.x));
        const v = Math.max(0, Math.min(DET_H-1, p.y));
        const uu = Math.floor(u), vv = Math.floor(v);
        const idx = (vv*DET_W + uu)*4;

        const odx = (y*WARP_SIZE + x)*4;
        odata[odx]   = sdata[idx];
        odata[odx+1] = sdata[idx+1];
        odata[odx+2] = sdata[idx+2];
        odata[odx+3] = 255;
      }
    }
    warpCtx.putImageData(out, 0, 0);
    return out;
  }

  // =========================
  // 8x8 추출 + 매칭
  // =========================
  function cellMeanGray(imgData, W, r, c, cell) {
    const { data } = imgData;

    const margin = Math.max(1, Math.floor(cell * 0.20));
    const x0 = c * cell + margin;
    const y0 = r * cell + margin;
    const x1 = (c + 1) * cell - margin;
    const y1 = (r + 1) * cell - margin;

    const vals = [];
    for (let y = y0; y < y1; y++) {
      for (let x = x0; x < x1; x++) {
        const idx = (y * W + x) * 4;
        vals.push(rgbToGray(data[idx], data[idx + 1], data[idx + 2]));
      }
    }

    // 안전: 값이 너무 적을 때(이론상 거의 없음) 처리
    if (vals.length < 10) {
      let sum = 0;
      for (const v of vals) sum += v;
      return vals.length ? (sum / vals.length) : 0;
    }

    // 트림 평균
    vals.sort((a,b)=>a-b);
    const cut = Math.floor(vals.length * 0.10);
    const slice = vals.slice(cut, vals.length - cut);

    let sum = 0;
    for (const v of slice) sum += v;
    return sum / slice.length;
  }

  function extractGrayVecFromWarp(imgData) {
    const W = WARP_SIZE;
    const cell = Math.floor(W / N);
    const v = new Float32Array(N*N);
    let k=0;
    for (let r=0;r<N;r++) {
      for (let c=0;c<N;c++) {
        v[k++] = cellMeanGray(imgData, W, r, c, cell);
      }
    }
    return v;
  }

  function rmseWithAffineFit(obs, target) {
    const n = obs.length;
    let meanO=0, meanT=0;
    for (let i=0;i<n;i++) { meanO += obs[i]; meanT += target[i]; }
    meanO/=n; meanT/=n;

    let varO=0, cov=0;
    for (let i=0;i<n;i++) {
      const xo=obs[i]-meanO;
      const yt=target[i]-meanT;
      varO += xo*xo;
      cov  += xo*yt;
    }
    if (varO < 1e-6) return Infinity;

    const a = cov/varO;
    if (a < 0) return Infinity;
    const b = meanT - a*meanO;

    let mse=0;
    for (let i=0;i<n;i++) {
      const diff = (a*obs[i] + b) - target[i];
      mse += diff*diff;
    }
    return Math.sqrt(mse/n);
  }

  function passesContrastGate(obs) {
    // 3레벨 패턴이 어두운 환경에서 미탐이 많으면 18 -> 14~16 정도로 낮춰보세요.
    const n=obs.length;
    let mean=0;
    for (let i=0;i<n;i++) mean += obs[i];
    mean/=n;
    let v=0;
    for (let i=0;i<n;i++) { const d=obs[i]-mean; v += d*d; }
    v/=n;
    return Math.sqrt(v) >= 18;
  }

  function scanFrameOnce() {
    if (!captureToDetCanvas()) return { best: Infinity, ok:false, bestId:null, bestUrl:null };

    const img = detCtx.getImageData(0,0,DET_W,DET_H);
    const gray = new Float32Array(DET_W*DET_H);
    for (let i=0, p=0; i<img.data.length; i+=4, p++) {
      gray[p] = rgbToGray(img.data[i], img.data[i+1], img.data[i+2]);
    }

    const mag = sobelEdges(gray, DET_W, DET_H);

    const quad = estimateQuadFromEdges(mag, DET_W, DET_H);
    if (!quad) return { best: Infinity, ok:false, bestId:null, bestUrl:null };

    const warped = warpFromDetCanvas(quad);
    if (!warped) return { best: Infinity, ok:false, bestId:null, bestUrl:null };

    const obs = extractGrayVecFromWarp(warped);
    if (!passesContrastGate(obs)) return { best: Infinity, ok:false, bestId:null, bestUrl:null };

    let best = Infinity, bestId=null, bestUrl=null;
    for (const p of ROT_PATTERNS) {
      for (const t of p.targets) {
        const s = rmseWithAffineFit(obs, t);
        if (s < best) { best = s; bestId=p.id; bestUrl=p.url; }
      }
    }
    return { best, ok: best <= RMSE_THRESHOLD, bestId, bestUrl };
  }

  function loop() {
    if (opened) return;

    let res;
    try {
      res = scanFrameOnce();
    } catch (e) {
      // 어떤 이유로든 프레임 처리 중 예외가 나면 죽지 말고 상태 표시
      console.error(e);
      setStatus("스캔 처리 중 오류(콘솔 확인): " + (e?.message || e));
      return;
    }

    if (res.ok) okStreak++;
    else okStreak = Math.max(0, okStreak - 1);

    setStatus(`스캔 중… score(RMSE)=${Number.isFinite(res.best)?res.best.toFixed(1):"inf"}, match=${res.bestId ?? "-"}, streak=${okStreak}`);

    if (okStreak >= 3 && res.bestUrl) {
      opened = true;
      if (timer) { clearInterval(timer); timer = null; } // 성공 시 루프 정리
      setStatus(`인식 성공(${res.bestId})! 이동합니다…`);
      window.location.href = res.bestUrl;
    }
  }

  async function startCamera() {
    opened = false;
    okStreak = 0;

    // 중복 시작 방지
    if (timer) { clearInterval(timer); timer = null; }
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }

    setStatus("카메라 권한 요청 중…");
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });

      video.srcObject = stream;

      btnStart.disabled = true;
      btnStop.disabled = false;

      // iOS/Safari 안정화: metadata+재생 보장
      await new Promise(resolve => {
        if (video.readyState >= 2) resolve();
        else video.onloadedmetadata = () => resolve();
      });

      // 일부 브라우저는 사용자 제스처 후에도 play가 reject될 수 있어 try/catch
      try { await video.play(); } catch (e) { /* 무시: autoplay 정책 */ }

      setStatus("스캔 시작! (자동으로 사각형을 찾습니다)");
      timer = setInterval(loop, SCAN_INTERVAL_MS);
    } catch (err) {
      console.error(err);
      setStatus("카메라 시작 실패: " + (err?.name ? `${err.name} - ${err.message || ""}` : err));
      btnStart.disabled = false;
      btnStop.disabled = true;
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    }
  }

  function stopCamera() {
    if (timer) { clearInterval(timer); timer = null; }
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    btnStart.disabled = false;
    btnStop.disabled = true;
    opened = false;
    okStreak = 0;
    setStatus("카메라 정지됨.");
  }

  btnStart.addEventListener("click", startCamera);
  btnStop.addEventListener("click", stopCamera);

  if (location.protocol !== "https:" && location.hostname !== "localhost") {
    setStatus("주의: 카메라는 HTTPS에서만 동작합니다. GitHub Pages로 배포하세요.");
  }
})();
</script>
</body>
</html>
