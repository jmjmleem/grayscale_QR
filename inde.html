<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GrayCode Camera Scanner</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; }
    .wrap { max-width: 720px; margin: 0 auto; }
    video { width: 100%; max-height: 70vh; background: #111; border-radius: 12px; object-fit: cover; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin: 12px 0; }
    button { padding: 10px 12px; font-size: 16px; }
    .status { padding: 10px 12px; background: #f3f4f6; border-radius: 12px; }
    .hint { color:#444; font-size: 14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>그레이 코드 실시간 인식</h2>
    <p class="hint">코드를 화면 중앙에 크게 맞추면 자동으로 이동합니다.</p>

    <div class="row">
      <button id="start">카메라 시작</button>
      <button id="stop" disabled>카메라 정지</button>
    </div>

    <div class="status" id="status">대기 중…</div>

    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas" style="display:none;"></canvas>
  </div>

<script>
(() => {
  const N = 8;

  // ✅ 패턴마다 3레벨/4레벨을 "명시"해서 인지
  const PATTERNS = [
    {
      id: "NPL_HOME",
      url: "https://npl.khu.ac.kr/",
      numLevels: 4, // 0..3
      levels: [
        [3,0,2,2,1,3,2,3],
        [3,2,3,0,1,0,3,2],
        [0,1,1,1,0,3,1,1],
        [1,2,0,2,0,3,3,3],
        [3,2,3,0,0,1,2,0],
        [0,0,2,3,0,0,1,1],
        [2,3,3,3,2,3,2,2],
        [2,2,1,1,2,3,2,2]
      ],
    },
    {
      id: "OSK",
      url: "https://www.osk.or.kr/conference/event/index.php?cfrid=136",
      numLevels: 3, // 0..2
      levels: [
        [0,2,1,0,0,0,0,1],
        [1,0,1,1,0,2,1,1],
        [2,0,0,2,1,2,2,1],
        [0,0,1,0,1,0,0,2],
        [2,1,0,2,0,1,0,0],
        [1,2,2,1,2,1,2,0],
        [0,2,2,0,0,2,1,0],
        [1,0,2,2,1,0,0,1]
      ],
    }
  ];

  // ===== 튜닝 =====
  const SCAN_INTERVAL_MS = 140;
  const RMSE_THRESHOLD = 80;
  const DET_W = 480, DET_H = 480;
  const WARP_SIZE = 300;

  // ===== DOM =====
  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnStart = document.getElementById("start");
  const btnStop  = document.getElementById("stop");

  function setStatus(msg) { statusEl.textContent = msg; }

  // ===== 404 원천 차단: 외부 절대 URL만 이동 허용 =====
  function safeNavigate(url) {
    try {
      if (typeof url !== "string") throw new Error("url is not string");

      // trim & normalize
      const s = url.trim();

      // 반드시 https:// 또는 http:// 로 시작해야만 이동
      if (!/^https?:\/\//i.test(s)) {
        throw new Error("not absolute http(s) url: " + s);
      }

      // URL 파싱 (이상하면 예외)
      const u = new URL(s);

      // 최종 이동(중복 이동 방지 위해 replace 사용)
      window.location.replace(u.href);
    } catch (e) {
      console.error("Navigate blocked:", url, e);
      setStatus("이동 차단(잘못된 URL): " + String(url));
      // ✅ 여기서 끝. 절대 GitHub Pages 내부 경로로는 안 감.
    }
  }

  // ===== 컨텍스트 폴백(willReadFrequently 미지원 브라우저) =====
  function get2dSafe(canvas) {
    return canvas.getContext("2d", { willReadFrequently: true }) || canvas.getContext("2d");
  }

  const detCanvas = document.createElement("canvas");
  detCanvas.width = DET_W; detCanvas.height = DET_H;
  const detCtx = get2dSafe(detCanvas);

  const warpCanvas = document.createElement("canvas");
  warpCanvas.width = WARP_SIZE; warpCanvas.height = WARP_SIZE;
  const warpCtx = get2dSafe(warpCanvas);

  if (!detCtx || !warpCtx) {
    setStatus("오류: 캔버스 2D 컨텍스트 생성 실패(브라우저 호환성).");
    return;
  }

  // ===== 패턴 검증 =====
  function validatePattern(p) {
    if (p.numLevels !== 3 && p.numLevels !== 4) {
      setStatus(`패턴 오류(${p.id}): numLevels는 3 또는 4`);
      return false;
    }
    if (!Array.isArray(p.levels) || p.levels.length !== N) {
      setStatus(`패턴 오류(${p.id}): levels는 ${N}x${N}`);
      return false;
    }
    const maxAllowed = p.numLevels - 1;
    for (const row of p.levels) {
      if (!Array.isArray(row) || row.length !== N) {
        setStatus(`패턴 오류(${p.id}): levels는 ${N}x${N}`);
        return false;
      }
      for (const v of row) {
        if (!Number.isFinite(v) || v < 0 || v > maxAllowed) {
          setStatus(`패턴 오류(${p.id}): 레벨 ${v} (허용 0..${maxAllowed})`);
          return false;
        }
      }
    }
    // URL도 미리 검증(프로토콜 없는 URL 방지)
    if (typeof p.url !== "string" || !/^https?:\/\//i.test(p.url.trim())) {
      setStatus(`패턴 오류(${p.id}): url은 반드시 https://... 형태`);
      return false;
    }
    return true;
  }

  for (const p of PATTERNS) {
    if (!validatePattern(p)) return;
  }

  // ===== 레벨→그레이 =====
  function levelToGray(numLevels) {
    return (numLevels === 3) ? [0, 127.5, 255] : [0, 85, 170, 255];
  }

  // obs를 3/4레벨 각각 양자화
  function quantizeObs(obs, numLevels) {
    const map = levelToGray(numLevels);
    const out = new Float32Array(obs.length);

    if (numLevels === 3) {
      const t1 = (map[0] + map[1]) / 2;
      const t2 = (map[1] + map[2]) / 2;
      for (let i=0;i<obs.length;i++) {
        const x = obs[i];
        out[i] = (x < t1) ? map[0] : (x < t2) ? map[1] : map[2];
      }
      return out;
    }

    const t1 = (map[0] + map[1]) / 2;
    const t2 = (map[1] + map[2]) / 2;
    const t3 = (map[2] + map[3]) / 2;
    for (let i=0;i<obs.length;i++) {
      const x = obs[i];
      out[i] = (x < t1) ? map[0] : (x < t2) ? map[1] : (x < t3) ? map[2] : map[3];
    }
    return out;
  }

  // ===== 회전/템플릿 =====
  function rotate90(m) {
    const out = Array.from({length:N}, () => Array(N).fill(0));
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) out[c][N-1-r] = m[r][c];
    return out;
  }

  function levelsToTargetVec(levels2d, map) {
    const v = new Float32Array(N*N);
    let k = 0;
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) v[k++] = map[levels2d[r][c]];
    return v;
  }

  const ROT_PATTERNS = PATTERNS.map(p => {
    const map = levelToGray(p.numLevels);
    const r0 = p.levels;
    const r1 = rotate90(r0);
    const r2 = rotate90(r1);
    const r3 = rotate90(r2);
    return {
      id: p.id,
      url: p.url.trim(),
      numLevels: p.numLevels,
      targets: [
        levelsToTargetVec(r0, map),
        levelsToTargetVec(r1, map),
        levelsToTargetVec(r2, map),
        levelsToTargetVec(r3, map),
      ]
    };
  });

  let stream = null;
  let timer = null;
  let opened = false;
  let okStreak = 0;

  function rgbToGray(r, g, b) {
    return 0.299*r + 0.587*g + 0.114*b;
  }

  function captureToDetCanvas() {
    const vw = video.videoWidth, vh = video.videoHeight;
    if (!vw || !vh) return false;

    const s = Math.min(vw, vh);
    const sx = Math.floor((vw - s)/2);
    const sy = Math.floor((vh - s)/2);
    detCtx.drawImage(video, sx, sy, s, s, 0, 0, DET_W, DET_H);
    return true;
  }

  function sobelEdges(gray, w, h) {
    const mag = new Float32Array(w*h);
    const idx = (x,y)=>y*w+x;
    for (let y=1;y<h-1;y++) {
      for (let x=1;x<w-1;x++) {
        const gx =
          -gray[idx(x-1,y-1)] + gray[idx(x+1,y-1)] +
          -2*gray[idx(x-1,y)]   + 2*gray[idx(x+1,y)] +
          -gray[idx(x-1,y+1)] + gray[idx(x+1,y+1)];
        const gy =
          -gray[idx(x-1,y-1)] -2*gray[idx(x,y-1)] -gray[idx(x+1,y-1)] +
           gray[idx(x-1,y+1)] +2*gray[idx(x,y+1)] +gray[idx(x+1,y+1)];
        mag[idx(x,y)] = Math.abs(gx) + Math.abs(gy);
      }
    }
    return mag;
  }

  function estimateQuadFromEdges(mag, w, h) {
    const arr = Array.from(mag);
    arr.sort((a,b)=>a-b);
    const thr = arr[Math.floor(arr.length*0.92)] || 0;
    if (thr <= 0) return null;

    let tl=null,tr=null,br=null,bl=null;
    let bestTL=Infinity, bestTR=Infinity, bestBR=-Infinity, bestBL=-Infinity;

    for (let y=0;y<h;y++) {
      for (let x=0;x<w;x++) {
        const m = mag[y*w+x];
        if (m < thr) continue;

        const s1 = x + y;
        const s2 = -x + y;

        if (s1 < bestTL) { bestTL = s1; tl = {x,y}; }
        if (s2 < bestTR) { bestTR = s2; tr = {x,y}; }
        if (s1 > bestBR) { bestBR = s1; br = {x,y}; }
        if (s2 > bestBL) { bestBL = s2; bl = {x,y}; }
      }
    }

    if (!tl || !tr || !br || !bl) return null;

    const areaApprox = Math.abs((br.x-tl.x)*(br.y-tl.y));
    if (areaApprox < (w*h*0.02)) return null;

    return [tl,tr,br,bl];
  }

  function computeHomography(src, dst) {
    const A = [];
    const b = [];
    for (let i=0;i<4;i++) {
      const x = src[i].x, y = src[i].y;
      const u = dst[i].x, v = dst[i].y;
      A.push([x,y,1, 0,0,0, -u*x, -u*y]); b.push(u);
      A.push([0,0,0, x,y,1, -v*x, -v*y]); b.push(v);
    }
    const n = 8;
    for (let col=0; col<n; col++) {
      let pivot = col;
      for (let r=col+1;r<n;r++) if (Math.abs(A[r][col]) > Math.abs(A[pivot][col])) pivot = r;
      [A[col], A[pivot]] = [A[pivot], A[col]];
      [b[col], b[pivot]] = [b[pivot], b[col]];

      const div = A[col][col];
      if (Math.abs(div) < 1e-9) return null;
      for (let c=col;c<n;c++) A[col][c] /= div;
      b[col] /= div;

      for (let r=0;r<n;r++) {
        if (r===col) continue;
        const factor = A[r][col];
        for (let c=col;c<n;c++) A[r][c] -= factor*A[col][c];
        b[r] -= factor*b[col];
      }
    }
    const h = b;
    return [
      [h[0],h[1],h[2]],
      [h[3],h[4],h[5]],
      [h[6],h[7],1]
    ];
  }

  function invert3x3(M) {
    const a=M[0][0], b=M[0][1], c=M[0][2];
    const d=M[1][0], e=M[1][1], f=M[1][2];
    const g=M[2][0], h=M[2][1], i=M[2][2];
    const A = e*i - f*h;
    const B = -(d*i - f*g);
    const C = d*h - e*g;
    const D = -(b*i - c*h);
    const E = a*i - c*g;
    const F = -(a*h - b*g);
    const G = b*f - c*e;
    const H = -(a*f - c*d);
    const I = a*e - b*d;
    const det = a*A + b*B + c*C;
    if (Math.abs(det) < 1e-9) return null;
    const invDet = 1/det;
    return [
      [A*invDet, D*invDet, G*invDet],
      [B*invDet, E*invDet, H*invDet],
      [C*invDet, F*invDet, I*invDet]
    ];
  }

  function applyH(H, x, y) {
    const nx = H[0][0]*x + H[0][1]*y + H[0][2];
    const ny = H[1][0]*x + H[1][1]*y + H[1][2];
    const nz = H[2][0]*x + H[2][1]*y + H[2][2];
    return { x: nx/nz, y: ny/nz };
  }

  function warpFromDetCanvas(quad) {
    const dst = [
      {x:0, y:0},
      {x:WARP_SIZE-1, y:0},
      {x:WARP_SIZE-1, y:WARP_SIZE-1},
      {x:0, y:WARP_SIZE-1},
    ];
    const H = computeHomography(quad, dst);
    if (!H) return null;
    const Hinv = invert3x3(H);
    if (!Hinv) return null;

    const srcImg = detCtx.getImageData(0,0,DET_W,DET_H);
    const sdata = srcImg.data;

    const out = warpCtx.createImageData(WARP_SIZE, WARP_SIZE);
    const odata = out.data;

    for (let y=0;y<WARP_SIZE;y++) {
      for (let x=0;x<WARP_SIZE;x++) {
        const p = applyH(Hinv, x, y);
        const u = Math.max(0, Math.min(DET_W-1, p.x));
        const v = Math.max(0, Math.min(DET_H-1, p.y));
        const uu = Math.floor(u), vv = Math.floor(v);
        const idx = (vv*DET_W + uu)*4;

        const odx = (y*WARP_SIZE + x)*4;
        odata[odx]   = sdata[idx];
        odata[odx+1] = sdata[idx+1];
        odata[odx+2] = sdata[idx+2];
        odata[odx+3] = 255;
      }
    }
    warpCtx.putImageData(out, 0, 0);
    return out;
  }

  function cellMeanGray(imgData, W, r, c, cell) {
    const { data } = imgData;
    const margin = Math.max(1, Math.floor(cell * 0.20));
    const x0 = c * cell + margin;
    const y0 = r * cell + margin;
    const x1 = (c + 1) * cell - margin;
    const y1 = (r + 1) * cell - margin;

    const vals = [];
    for (let y = y0; y < y1; y++) {
      for (let x = x0; x < x1; x++) {
        const idx = (y * W + x) * 4;
        vals.push(rgbToGray(data[idx], data[idx + 1], data[idx + 2]));
      }
    }
    if (vals.length === 0) return 0;

    vals.sort((a,b)=>a-b);
    const cut = Math.floor(vals.length * 0.10);
    const slice = vals.slice(cut, vals.length - cut);
    let sum = 0;
    for (const v of slice) sum += v;
    return sum / slice.length;
  }

  function extractGrayVecFromWarp(imgData) {
    const W = WARP_SIZE;
    const cell = Math.floor(W / N);
    const v = new Float32Array(N*N);
    let k=0;
    for (let r=0;r<N;r++) {
      for (let c=0;c<N;c++) {
        v[k++] = cellMeanGray(imgData, W, r, c, cell);
      }
    }
    return v;
  }

  function rmseWithAffineFit(obs, target) {
    const n = obs.length;
    let meanO=0, meanT=0;
    for (let i=0;i<n;i++) { meanO += obs[i]; meanT += target[i]; }
    meanO/=n; meanT/=n;

    let varO=0, cov=0;
    for (let i=0;i<n;i++) {
      const xo=obs[i]-meanO;
      const yt=target[i]-meanT;
      varO += xo*xo;
      cov  += xo*yt;
    }
    if (varO < 1e-6) return Infinity;

    const a = cov/varO;
    if (a < 0) return Infinity;
    const b = meanT - a*meanO;

    let mse=0;
    for (let i=0;i<n;i++) {
      const diff = (a*obs[i] + b) - target[i];
      mse += diff*diff;
    }
    return Math.sqrt(mse/n);
  }

  function passesContrastGate(obs) {
    const n=obs.length;
    let mean=0;
    for (let i=0;i<n;i++) mean += obs[i];
    mean/=n;
    let v=0;
    for (let i=0;i<n;i++) { const d=obs[i]-mean; v += d*d; }
    v/=n;
    return Math.sqrt(v) >= 18;
  }

  function scanFrameOnce() {
    if (!captureToDetCanvas()) return { best: Infinity, ok:false, bestId:null, bestUrl:null };

    const img = detCtx.getImageData(0,0,DET_W,DET_H);
    const gray = new Float32Array(DET_W*DET_H);
    for (let i=0, p=0; i<img.data.length; i+=4, p++) {
      gray[p] = rgbToGray(img.data[i], img.data[i+1], img.data[i+2]);
    }

    const mag = sobelEdges(gray, DET_W, DET_H);
    const quad = estimateQuadFromEdges(mag, DET_W, DET_H);
    if (!quad) return { best: Infinity, ok:false, bestId:null, bestUrl:null };

    const warped = warpFromDetCanvas(quad);
    if (!warped) return { best: Infinity, ok:false, bestId:null, bestUrl:null };

    const obs = extractGrayVecFromWarp(warped);
    if (!passesContrastGate(obs)) return { best: Infinity, ok:false, bestId:null, bestUrl:null };

    // ✅ 3레벨/4레벨 관측치 분리
    const obs3 = quantizeObs(obs, 3);
    const obs4 = quantizeObs(obs, 4);

    let best = Infinity, bestId=null, bestUrl=null;
    for (const p of ROT_PATTERNS) {
      const obsQ = (p.numLevels === 3) ? obs3 : obs4;
      for (const t of p.targets) {
        const s = rmseWithAffineFit(obsQ, t);
        if (s < best) { best = s; bestId=p.id; bestUrl=p.url; }
      }
    }
    return { best, ok: best <= RMSE_THRESHOLD, bestId, bestUrl };
  }

  function loop() {
    if (opened) return;

    const res = scanFrameOnce();
    if (res.ok) okStreak++;
    else okStreak = Math.max(0, okStreak - 1);

    setStatus(`스캔 중… RMSE=${Number.isFinite(res.best)?res.best.toFixed(1):"inf"}, match=${res.bestId ?? "-"}, streak=${okStreak}`);

    if (okStreak >= 3 && res.bestUrl) {
      opened = true;
      if (timer) { clearInterval(timer); timer = null; } // ✅ 중복 이동 방지
      setStatus(`인식 성공(${res.bestId})! 이동합니다…`);
      safeNavigate(res.bestUrl); // ✅ 404 원천 차단
    }
  }

  async function startCamera() {
    opened = false;
    okStreak = 0;

    setStatus("카메라 권한 요청 중…");
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;

      btnStart.disabled = true;
      btnStop.disabled = false;

      await new Promise(resolve => {
        if (video.readyState >= 2) resolve();
        else video.onloadedmetadata = () => resolve();
      });

      try { await video.play(); } catch(e) {}

      setStatus("스캔 시작! (자동으로 사각형을 찾습니다)");
      timer = setInterval(loop, SCAN_INTERVAL_MS);
    } catch (err) {
      setStatus("카메라 시작 실패: " + (err?.name ? `${err.name} - ${err.message || ""}` : err));
    }
  }

  function stopCamera() {
    if (timer) { clearInterval(timer); timer = null; }
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    btnStart.disabled = false;
    btnStop.disabled = true;
    setStatus("카메라 정지됨.");
  }

  btnStart.addEventListener("click", startCamera);
  btnStop.addEventListener("click", stopCamera);

  if (location.protocol !== "https:" && location.hostname !== "localhost") {
    setStatus("주의: 카메라는 HTTPS에서만 동작합니다. GitHub Pages로 배포하세요.");
  }
})();
</script>
</body>
</html>
